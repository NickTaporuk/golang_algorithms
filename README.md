# golang_algorithms
golang algorithms
### Асимптотическая сложность
* Асимптотическая сложность (производительность) определяется функцией, которая указывает, насколько ухудшается работа алгоритма с усложнением поставленной задачи. Такую функцию записывают в круглых скобках, предваряя прописной буквой О.
* Существуют пять основных правил для расчета асимптотической сложности алгоритма.
  1. Еслидляматематическойфункцииfалгоритмунеобходимовыполнитьопределенные действия f(N) раз, то для этого ему понадобится сделать O(f(N)) шагов.
  2. Если алгоритм выполняет одну операцию, состоящую из O(f(N)) шагов, а затем вторую операцию, включающую O(g(N)) шагов, то общая производительность алгоритма для функций f и g составит O(f(N) + g(N)).
  3. ЕслиалгоритмунеобходимосделатьO(f(N)+g(N))шаговиобластьзначений N функции f(N) больше, чем у g(N), то асимптотическую сложность можно упростить до выражения O(f(N)).
  4. Если алгоритму внутри каждого шага O(f(N)) одной операции приходится выполнять еще O(g(N)) шагов другой операции, то общая производительность алгоритма составит O(f(N) u g(N)).
  5. Постояннымимножителями(константами)можнопренебречь.Если C является константой, то O(C u f(N)) или O(f(C u N)) можно записать как O(f(N)).

* Правило 1
  Если для математической функции f алгоритму необходимо выполнить определенные действия f(N) раз, то для этого ему понадобится сделать O(f(N)) шагов.
  + Рассмотрим псевдокод с алгоритмом по нахождению наибольшего целого числа в массиве.
      ```
        Integer: FindLargest(Integer: array[])
         Integer: largest = array[0]
         For i = 1 To <наибольший индекс>
                 If (array[i] > largest) Then largest = array[i]
         Next i
          Return largest
      End FindLargest
      ```
  + В качестве входного параметра алгоритм FindLargest использует массив целых чисел, результат возвращается в виде одного целого числа. В самом начале переменной largest присваивается значение первого элемента массива. Затем алгоритм перебирает оставшиеся элементы и сравнивает значение каждого из них с largest. Если он находит большую величину, то приравнивает largest к ней и по окончании цикла возвращает наибольшее найденное значение.
  Алгоритм проверяет каждый из N элементов массива всего один раз, поэтому его производительность составляет O(N).

* Правило 2
  + Если алгоритм выполняет одну операцию, состоящую из O(f(N)) шагов, а затем вторую, требующую O(g(N)) шагов, то общая производительность алгоритма для функций f и g будет O(f(N) + g(N)).
  + Вернемся к алгоритму FindLargest. На этот раз обратите внимание, что несколько строк в действительности не включены в цикл. В следующем псевдокоде в комментариях справа приведен порядок времени выполнения все тех же шагов.
      ```
      Integer: FindLargest(Integer: array[])
         Integer: largest = array[0]            // O(1)
         For i = 1 To <наибльший индекс>        // O(N)
                 If (array[i] > largest) Then largest = array[i]
         Next i
         Return largest                         // O(1)
      End FindLargest
      ```
  + Итак, приведенный алгоритм выполняет один шаг отладки перед циклом и еще один после него. Каждый из них имеет производительность O(1) (это однократное действие), поэтому общее время работы алгоритма составит O(1 + N + 1). Если использовать обычную алгебру и преобразовать выражение, то получится O(2 + N).

* Правило 3
  + Если алгоритму необходимо сделать O(f(N) + g(N)) шагов и область значений N функции f(N) больше, чем у g(N), то асимптотическую сложность можно упростить до выражения O(f(N)).
  + В предыдущем примере мы выяснили, что время работы алгоритма FindLargest определяется выражением O(2 + N). Если параметр N начнет возрастать, его значение превысит постоянную величину 2 и предыдущее выражение можно будет упростить до O(N).
  + Игнорирование меньших функций позволяет пренебречь небольшими задачами отладки и очистки, чтобы сосредоточить внимание на асимптотическом поведении алгоритма, которое обнаруживается при усложнении задачи. Другими словами, время, затраченное алгоритмом на построение простых структур данных перед выполнением объемного вычисления, является несущественным по сравнению с длительностью основных расчетов.
* Правило 4
  + Если алгоритму внутри каждого шага O(f(N)) одной операции приходится выполнять еще O(g(N)) шагов другой операции, то общая производительность алгоритма составит O(f(N) u g(N)).
  + Рассмотрим алгоритм, который определяет, содержатся ли в массиве повторяющиеся элементы. (Стоит отметить, что это не самый эффективный способ обнаружения дубликатов.)
      ```
      Boolean: ContainsDuplicates(Integer: array[])
         // Цикл по всем элементам массива.
         For i = 0 To <наибольший индекс>
            For j = 0 To <наибольший индекс>
            // Проверяем, являются ли два элемента дубликатами. If (i != j) Then
                If (i != j) Then
                    If (array[i] == array[j]) Then Return True
                End If
            Next j
         Next i
        // Если мы дошли до этой строки, то дубликатов нет.
        Return False
    End ContainsDuplicates
    ```
  + Алгоритм содержит два цикла, один из которых является вложенным. Внешний цикл перебирает все элементы массива N, выполняя O(N) шагов. Внутри каждого такого шага внутренний цикл повторно пересматривает все N элементов массива, совершая те же O(N) шагов. Следовательно, общая производительность алгоритма составит O(N u N) = O(N2).
* Правило 5
  + Постоянными множителями (константами) можно пренебречь. Если C является константой, то O(C u f(N)) или O(f(C u N)) можно записать как O(f(N)).
  + Снова посмотрите на алгоритм ContainsDuplicates из предыдущего примера и обратите внимание на внутренний цикл, который представлен условием If. В рамках этого условия определяется, равны ли друг другу индексы i и j. Если нет — тогда сравниваются величины array[i] и array[j], в случае их совпадения возвращается значение True.
  + Пренебрегая дополнительным шагом в выражении Return (как правило, он выполняется один раз), предположим, что срабатывают оба оператора If (а так и происходит в большинстве случаев), тогда внутренний цикл будет пройден за O(2N) шагов. Следовательно, общая производительность алгоритма составит O(N u 2N) = = O(2N2). Последнее правило позволяет пренебречь коэффициентом 2 и записать производительность алгоритма в виде O(N2).
  + На самом деле мы возвращаемся к сути асимптотической сложности: нужно выяснить, как поведет себя алгоритм, если N начнет возрастать. Предположим, вы увеличите N в два раза, то есть будете оперировать значением 2N. Теперь если подставить фразу в выражение 2N2, получится следующее: 2 u (2N)2 = 2 u 4N2 = 8N2. Это и есть наша величина 2N2, только умноженная на 4. Таким образом, время работы алгоритма увеличится в четыре раза.
  + Теперь давайте оценим производительность алгоритма, используя упрощенное по правилу выражение O(N2). При подстановке в него 2N получим следующее: (2N)2 = 4N2. То есть наша изначальная величина N2 возросла в четыре раза, как и время работы алгоритма.
  + Из всего вышесказанного следует, что независимо от того, будете вы использовать развернутую формулу 2N2 или ограничитесь просто N2, результат останется прежним: увеличение сложности задачи в два раза замедлит работу алгоритма в четыре раза. Таким образом, важной здесь является не константа 2,а тот факт, что время работы увеличивается вместе с увеличением количества вводов N2.
  + ЗАМЕЧАНИЕ
    + Важно помнить, что асимптотическая сложность дает представление о теоретическом поведении алгоритма. Практические результаты могут отличаться. Предположим, производительность алгоритма равна O(N); если не пренебрегать целыми числами, реальное количество выполняемых шагов составит приблизительно 100 000 000 + N. В этом случае, пока N не слишком велико, значение константы лучше учитывать.